LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;
USE IEEE.MATH_REAL.ALL;
USE std.textio.ALL;
USE work.cache_pkg.ALL;
USE work.utils_pkg.ALL;
USE work.cache_test_pkg.ALL;
ENTITY direct_mapped_cache_tb IS
	GENERIC (
		TAG_FILENAME : STRING := "./imem/tag";
		DATA_FILENAME : STRING := "./imem/data";
		FILE_EXTENSION : STRING := ".txt"
	);
END;
ARCHITECTURE testbench OF direct_mapped_cache_tb IS
	CONSTANT clock_period : TIME := 10 ns;
	CONSTANT C_FILE_NAME : STRING := "test_results/direct_mapped_cache.txt";
	CONSTANT TEST_TIME : TIME := 10000 ns;

	SIGNAL reset : STD_LOGIC := '0';
	SIGNAL clk : STD_LOGIC := '0';
	SIGNAL add_cpu : STD_LOGIC_VECTOR(DEFAULT_MEMORY_ADDRESS_WIDTH - 1 DOWNTO 0) := (OTHERS => '0');
	SIGNAL data_cpu : STD_LOGIC_VECTOR(DEFAULT_DATA_WIDTH - 1 DOWNTO 0) := (OTHERS => 'Z');
	SIGNAL valid : STD_LOGIC := '0';
	SIGNAL dirty : STD_LOGIC := '0';
	SIGNAL hit : STD_LOGIC := '0';
	SIGNAL wr_rd : STD_LOGIC := '0';
	SIGNAL cache_memory_data_bus : STD_LOGIC_VECTOR(CACHE_BLOCK_LINE_RANGE) := (OTHERS => '0');
	SIGNAL new_cache_block_line : STD_LOGIC_VECTOR(CACHE_BLOCK_LINE_RANGE);
	SIGNAL rd_word : STD_LOGIC := '0';
	SIGNAL wr_word : STD_LOGIC := '0';
	SIGNAL rd_cache_block_line : STD_LOGIC := '0';
	SIGNAL wr_cache_block_Line : STD_LOGIC := '0';
	SIGNAL set_valid : STD_LOGIC := '0';
	SIGNAL set_dirty : STD_LOGIC := '0';
	SIGNAL cs : STD_LOGIC := '0';
	SIGNAL my_data_word : STD_LOGIC_VECTOR(DEFAULT_DATA_WIDTH - 1 DOWNTO 0) := (OTHERS => '0');
	SIGNAL eof : std_logic := '0';
	SIGNAL trig : std_logic := '0';
	FILE fptr : text;

	-- clock gen component
	COMPONENT clock_gen
		GENERIC (clock_period : TIME);
		PORT (
			clk : OUT std_logic
		);
	END COMPONENT;
	COMPONENT cpu_gen
		PORT (
			clk : IN STD_LOGIC;
			rst : IN STD_LOGIC;
			trig : IN STD_LOGIC;
			Address : OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
			wr_rd : OUT STD_LOGIC;
			cs : OUT STD_LOGIC;
			DOut : OUT STD_LOGIC_VECTOR (7 DOWNTO 0)
		);
	END COMPONENT;
	COMPONENT direct_mapped_cache
		GENERIC (
			TAG_FILENAME : STRING;
			DATA_FILENAME : STRING;
			FILE_EXTENSION : STRING
		);
		PORT (
			clk : IN STD_LOGIC;
			reset : IN STD_LOGIC;
			add_cpu : IN STD_LOGIC_VECTOR(DEFAULT_MEMORY_ADDRESS_WIDTH - 1 DOWNTO 0);
			data_cpu : INOUT STD_LOGIC_VECTOR(DEFAULT_DATA_WIDTH - 1 DOWNTO 0);
			new_cache_block_line : IN STD_LOGIC_VECTOR(DEFAULT_DATA_WIDTH * DEFAULT_BLOCK_SIZE - 1 DOWNTO 0);
			cache_memory_data_bus : OUT STD_LOGIC_VECTOR(DEFAULT_DATA_WIDTH * DEFAULT_BLOCK_SIZE - 1 DOWNTO 0);
			wr_cache_block_Line : IN STD_LOGIC;
			rd_cache_block_line : IN STD_LOGIC;
			rd_word : IN STD_LOGIC;
			wr_word : IN STD_LOGIC;
			wr_rd : IN STD_LOGIC;
			valid : INOUT STD_LOGIC;
			dirty : INOUT STD_LOGIC;
			set_valid : IN STD_LOGIC;
			set_dirty : IN STD_LOGIC;
			hit : OUT STD_LOGIC
		);
	END COMPONENT;

BEGIN
	-- Clock generator instl
	clock_gen_instl : clock_gen
	GENERIC MAP(clock_period => clock_period)
	PORT MAP(
		clk => clk
	);
	-- cpu gen instl 
	cpu_gen_instl : cpu_gen
	PORT MAP(
		clk => clk,
		rst => reset,
		trig => trig,
		Address => add_cpu,
		wr_rd => wr_rd,
		cs => cs,
		DOut => data_cpu
	);
	-- unit under test
	uut : direct_mapped_cache
	GENERIC MAP(
		TAG_FILENAME => TAG_FILENAME,
		DATA_FILENAME => DATA_FILENAME,
		FILE_EXTENSION => FILE_EXTENSION
	)
	PORT MAP(
		clk => clk,
		reset => reset,
		data_cpu => data_cpu,
		add_cpu => add_cpu,
		cache_memory_data_bus => cache_memory_data_bus,
		rd_word => rd_word,
		-- wr_word => wr_word,
		wr_word => wr_rd,
		wr_cache_block_Line => wr_cache_block_Line,
		rd_cache_block_line => rd_cache_block_line,
		wr_rd => wr_rd,
		valid => valid,
		dirty => dirty,
		set_valid => set_valid,
		set_dirty => set_dirty,
		hit => hit,
		new_cache_block_line => new_cache_block_line
	);
	-- 

	stim_proc : PROCESS
		VARIABLE counter : INTEGER;
		VARIABLE old_addr : STD_LOGIC_VECTOR (15 DOWNTO 0);

		VARIABLE L : line;
		VARIABLE fstatus : file_open_status;
		VARIABLE temp : STD_LOGIC_VECTOR (1 TO 1);
	BEGIN
		WAIT FOR 1 ns;
		write(L, STRING'("cache controller tests "));
		writeline(output, L);
		data_cpu <= (OTHERS => 'Z');
		rd_word <= NOT wr_rd;

		reset <= '1';
		counter := 1;
		file_open(fstatus, fptr, C_FILE_NAME, write_mode);
		WAIT UNTIL rising_edge(clk);
		-- WAIT UNTIL falling_edge(clk);
		eof <= '0';
		reset <= '0';
		rd_word <= NOT wr_rd;
		WAIT UNTIL rising_edge(clk);
		-- WAIT UNTIL falling_edge(clk);
		WHILE (counter * 10 ns < TEST_TIME) LOOP
			WAIT UNTIL rising_edge(clk);
			-- WAIT UNTIL cs = '1';
			counter := counter + 1;
			rd_word <= NOT wr_rd;
			trig <= NOT trig;
			-- set_valid<=valid;
			-- set_dirty<=	dirty;
			IF old_addr /= add_cpu THEN
				old_addr := add_cpu;
				temp(1) := wr_rd;

				write(L, STRING'("wr_rd : "));
				write(L, TO_STRING(temp));
				-- writeline(output, L);
				writeline(fptr, L);
				temp(1) := cs;
				write(L, STRING'("cs : "));
				write(L, TO_STRING(temp));
				-- writeline(output, L);
				writeline(fptr, L);
				temp(1) := valid;
				write(L, STRING'("valid : "));
				write(L, TO_STRING(temp));
				-- writeline(output, L);
				writeline(fptr, L);
				temp(1) := dirty;
				write(L, STRING'("dirty : "));
				write(L, TO_STRING(temp));
				-- writeline(output, L);
				writeline(fptr, L);
				temp(1) := hit;
				write(L, STRING'("hit : "));
				write(L, TO_STRING(temp));
				-- writeline(output, L);
				writeline(fptr, L);

				write(L, STRING'("data_cpu : "));
				write(L, TO_STRING(data_cpu));
				-- writeline(output, L);
				writeline(fptr, L);
				write(L, STRING'("add_cpu : "));
				write(L, TO_STRING(add_cpu));
				-- writeline(output, L);
				writeline(fptr, L);
				write(L, STRING'("tag : "));
				write(L, TO_STRING(GET_TAG(add_cpu)));
				-- writeline(output, L);
				writeline(fptr, L);
				write(L, STRING'("index : "));
				write(L, TO_STRING(GET_INDEX(add_cpu)));
				-- writeline(output, L);
				writeline(fptr, L);
				write(L, STRING'("offset : "));
				write(L, TO_STRING(GET_OFFSET(add_cpu)));
				-- writeline(output, L);
				writeline(fptr, L);
				write(L, STRING'("cache_memory_data_bus : "));
				write(L, TO_STRING(cache_memory_data_bus));
				-- writeline(output, L);
				writeline(fptr, L);
				write(L, STRING'("----------------------------------------------------------------------"));
				-- writeline(output, L);
				writeline(fptr, L);
			END IF;

			-- WAIT UNTIL falling_edge(clk);
		END LOOP;
		WAIT UNTIL rising_edge(clk);
		-- WAIT UNTIL falling_edge(clk);
		eof <= '1';
		file_close(fptr);
		WAIT;
		-- end if;

	END PROCESS;

END;